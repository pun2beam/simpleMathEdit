<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="./favicon.ico" sizes="any">
  <link rel="stylesheet" href="./style.css" />
  <title>MathJax Live Preview</title>

  <!-- MathJax v3 -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
      },
    };
  </script>
  <script defer src="./es5/tex-mml-chtml.js"></script>
  <script src="./marked/marked.min.js"></script>

</head>
<body>
  <div class="wrap">
    <div class="pane" id="left-pane">
      <div class="editor-header">
        <label class="file-label" for="file-name">ファイル名:</label>
        <input id="file-name" type="text" placeholder="ファイル名" value="notes" />
        <button id="save-button" type="button">Save</button>
        <button id="load-button" type="button">Load</button>
        <input id="file-input" type="file" accept=".md,text/markdown,text/plain" hidden />
      </div>
      <label class="caret-toggle">
        <input id="show-caret" type="checkbox" checked />
        キャレットをプレビューに表示
      </label>
      <textarea id="src">
インライン: $E=mc^2$

別行表示:
$$
\frac{\mathrm{d}y}{\mathrm{d}x}=g(y)h(x)
$$
      </textarea>
    </div>

    <div class="resizer" id="resizer" role="separator" aria-label="Resize panes" aria-orientation="vertical"></div>

    <div class="pane preview" id="right-pane">
      <div id="out"></div>
    </div>
  </div>

  <script>
    const src = document.getElementById('src');
    const out = document.getElementById('out');
    const resizer = document.getElementById('resizer');
    const leftPane = document.getElementById('left-pane');
    const rightPane = document.getElementById('right-pane');
    const fileNameInput = document.getElementById('file-name');
    const saveButton = document.getElementById('save-button');
    const loadButton = document.getElementById('load-button');
    const fileInput = document.getElementById('file-input');
    const showCaret = document.getElementById('show-caret');
    let timer = null;
    let renderInProgress = false;
    let renderQueued = false;
    let dragging = false;

    marked.setOptions({ mangle: false, headerIds: false });

    const caretToken = '│';
    const caretHtml = '<span id="caret-marker" aria-hidden="true" data-mjx-skip="true">▌</span>';

    function buildSourceWithCaret() {
      const caretIndex = src.selectionStart ?? 0;
      return `${src.value.slice(0, caretIndex)}${caretToken}${src.value.slice(caretIndex)}`;
    }

    function syncScrollFromSource() {
      const outMax = out.scrollHeight - rightPane.clientHeight;
      if (outMax <= 0) {
        rightPane.scrollTop = 0;
        return;
      }
      const caretIndex = src.selectionStart ?? 0;
      const beforeCaret = src.value.slice(0, caretIndex);
      const caretLine = beforeCaret.split('\n').length;
      const totalLines = Math.max(src.value.split('\n').length, 1);
      const ratio = Math.min(Math.max((caretLine - 1) / Math.max(totalLines - 1, 1), 0), 1);
      const targetScrollTop = ratio * outMax;
      rightPane.scrollTop = targetScrollTop;
    }

    function normalizeDisplayMath(source) {
      const lines = source.split('\n');
      const normalized = [];
      let inDisplay = false;

      for (let line of lines) {
        if (line.trim() === '$$') {
          inDisplay = !inDisplay;
          normalized.push('$$');
          continue;
        }

        if (inDisplay && line.trim() === '') {
          continue;
        }

        if (inDisplay) {
          line = line.replace(/\\/g, '\\\\');
        }

        normalized.push(line);
      }

      return normalized.join('\n');
    }

    function formatDateTime(date) {
      const pad = (value) => String(value).padStart(2, '0');
      return `${date.getFullYear()}${pad(date.getMonth() + 1)}${pad(date.getDate())}${pad(date.getHours())}${pad(date.getMinutes())}`;
    }

    function getBaseFileName() {
      const rawName = fileNameInput.value.trim();
      return rawName === '' ? 'notes' : rawName.replace(/\.md$/i, '');
    }

    function buildDownloadFileName(baseName) {
      const timestamp = formatDateTime(new Date());
      return `${baseName}_${timestamp}.md`;
    }

    function normalizeLoadedFileName(fileName) {
      const match = fileName.match(/^(.*)_([0-9]+)\.md$/i);
      if (match && /^[0-9]+$/.test(match[2])) {
        return match[1];
      }
      if (/\.md$/i.test(fileName)) {
        return fileName.replace(/\.md$/i, '');
      }
      return fileName;
    }

    async function render() {
      if (renderInProgress) {
        renderQueued = true;
        return;
      }
      renderInProgress = true;
      const sourceWithCaret = normalizeDisplayMath(
        showCaret.checked ? buildSourceWithCaret() : src.value
      );
      // const html = marked.parse(sourceWithCaret);
      // out.innerHTML = html.replace(caretToken, caretHtml);
      out.innerHTML = marked.parse(sourceWithCaret);
      renderPlots(out);

      // MathJaxの準備完了待ち（初回読み込み中の事故防止）
      if (!window.MathJax || !MathJax.typesetPromise) {
        renderInProgress = false;
        return;
      }

      // 右ペインだけ再レンダリング
      MathJax.typesetClear([out]);
      try {
        await MathJax.typesetPromise([out]);
        syncScrollFromSource();
      } finally {
        renderInProgress = false;
        if (renderQueued) {
          renderQueued = false;
          scheduleRender();
        }
      }
    }

    const plotColors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'];
    const plotResizeObservers = new WeakMap();

    function parseRangeAttribute(value, fallback) {
      if (!value) return fallback;
      const matches = value.match(/[-+]?\d*\.?\d+(?:e[-+]?\d+)?/gi);
      if (!matches || matches.length < 2) return fallback;
      const min = Number(matches[0]);
      const max = Number(matches[1]);
      if (!Number.isFinite(min) || !Number.isFinite(max) || min === max) return fallback;
      return [min, max];
    }

    function parseStepAttribute(value, fallback) {
      if (!value) return fallback;
      const step = Number(value);
      if (!Number.isFinite(step) || step <= 0) return fallback;
      return step;
    }

    function normalizeExpression(expression) {
      return expression
        .replace(/\bpi\b/gi, 'Math.PI')
        .replace(/\be\b/g, 'Math.E')
        .replace(/\bpower\s*\(/gi, 'Math.pow(')
        .replace(/\blog\s*\(/gi, '__log(')
        .replace(/\bsin\s*\(/gi, 'Math.sin(')
        .replace(/\bcos\s*\(/gi, 'Math.cos(')
        .replace(/\btan\s*\(/gi, 'Math.tan(');
    }

    function compileExpression(expression) {
      const normalized = normalizeExpression(expression);
      return new Function('x', '__log', `return (${normalized});`);
    }

    function compileSurfaceExpression(expression) {
      const normalized = normalizeExpression(expression);
      return new Function('x', 'y', '__log', `return (${normalized});`);
    }

    function compileParametricExpression(expression) {
      const normalized = normalizeExpression(expression);
      return new Function('u', 'v', '__log', `return (${normalized});`);
    }

    function renderPlots(container) {
      render2dPlots(container);
      render3dPlots(container);
    }

    function render2dPlots(container) {
      const plotBlocks = Array.from(container.querySelectorAll('plots'));
      plotBlocks.forEach((plotBlock) => {
        const axis = plotBlock.querySelector('axis');
        const [xMin, xMax] = parseRangeAttribute(axis?.getAttribute('x'), [-10, 10]);
        const [yMin, yMax] = parseRangeAttribute(axis?.getAttribute('y'), [-10, 10]);
        const plotEntries = Array.from(plotBlock.querySelectorAll('plot'))
          .map((plotNode) => plotNode.getAttribute('y'))
          .filter(Boolean);

        const wrapper = document.createElement('div');
        wrapper.className = 'plot-container';
        wrapper.setAttribute('data-mjx-skip', 'true');

        const canvas = document.createElement('canvas');
        canvas.className = 'plot-canvas';
        wrapper.appendChild(canvas);

        if (plotEntries.length > 0) {
          const legend = document.createElement('div');
          legend.className = 'plot-legend';
          plotEntries.forEach((expression, index) => {
            const item = document.createElement('div');
            item.className = 'plot-legend-item';
            const swatch = document.createElement('span');
            swatch.className = 'plot-legend-swatch';
            swatch.style.backgroundColor = plotColors[index % plotColors.length];
            item.appendChild(swatch);
            const label = document.createElement('span');
            label.textContent = `y = ${expression}`;
            item.appendChild(label);
            legend.appendChild(item);
          });
          wrapper.appendChild(legend);
        }

        plotBlock.replaceWith(wrapper);
        drawPlot(canvas, plotEntries, { xMin, xMax, yMin, yMax });

        if (!plotResizeObservers.has(wrapper)) {
          const observer = new ResizeObserver(() => {
            drawPlot(canvas, plotEntries, { xMin, xMax, yMin, yMax });
          });
          observer.observe(wrapper);
          plotResizeObservers.set(wrapper, observer);
        }
      });
    }

    function render3dPlots(container) {
      const plotBlocks = Array.from(container.querySelectorAll('plots3d'));
      plotBlocks.forEach((plotBlock) => {
        const axis = plotBlock.querySelector('axis');
        const axisXValue = axis?.getAttribute('x');
        const axisYValue = axis?.getAttribute('y');
        const axisZValue = axis?.getAttribute('z');
        const axisUValue = axis?.getAttribute('u');
        const axisVValue = axis?.getAttribute('v');
        const [xMin, xMax] = parseRangeAttribute(axisXValue, [-5, 5]);
        const [yMin, yMax] = parseRangeAttribute(axisYValue, [-5, 5]);
        const [zMin, zMax] = parseRangeAttribute(axisZValue, [-5, 5]);
        const [uMin, uMax] = parseRangeAttribute(axisUValue, [0, 1]);
        const [vMin, vMax] = parseRangeAttribute(axisVValue, [0, 1]);
        const step = parseStepAttribute(axis?.getAttribute('step'), 0.5);
        const plotEntries = Array.from(plotBlock.querySelectorAll('surface'))
          .map((surfaceNode) => surfaceNode.getAttribute('z'))
          .filter(Boolean);
        const parametricEntries = Array.from(plotBlock.querySelectorAll('parametric'))
          .map((parametricNode) => ({
            x: parametricNode.getAttribute('x'),
            y: parametricNode.getAttribute('y'),
            z: parametricNode.getAttribute('z'),
          }))
          .filter((entry) => entry.x && entry.y && entry.z);

        const wrapper = document.createElement('div');
        wrapper.className = 'plot-container';
        wrapper.setAttribute('data-mjx-skip', 'true');

        const canvas = document.createElement('canvas');
        canvas.className = 'plot-canvas';
        wrapper.appendChild(canvas);

        if (plotEntries.length > 0 || parametricEntries.length > 0) {
          const legend = document.createElement('div');
          legend.className = 'plot-legend';
          plotEntries.forEach((expression, index) => {
            const item = document.createElement('div');
            item.className = 'plot-legend-item';
            const swatch = document.createElement('span');
            swatch.className = 'plot-legend-swatch';
            swatch.style.backgroundColor = plotColors[index % plotColors.length];
            item.appendChild(swatch);
            const label = document.createElement('span');
            label.textContent = `z = ${expression}`;
            item.appendChild(label);
            legend.appendChild(item);
          });
          parametricEntries.forEach((entry, index) => {
            const item = document.createElement('div');
            item.className = 'plot-legend-item';
            const swatch = document.createElement('span');
            swatch.className = 'plot-legend-swatch';
            swatch.style.backgroundColor = plotColors[(index + plotEntries.length) % plotColors.length];
            item.appendChild(swatch);
            const label = document.createElement('span');
            label.textContent = `parametric: x = ${entry.x}, y = ${entry.y}, z = ${entry.z}`;
            item.appendChild(label);
            legend.appendChild(item);
          });
          wrapper.appendChild(legend);
        }

        plotBlock.replaceWith(wrapper);
        drawPlot3d(canvas, plotEntries, parametricEntries, {
          xMin,
          xMax,
          yMin,
          yMax,
          zMin,
          zMax,
          uMin,
          uMax,
          vMin,
          vMax,
          step,
          axisHasX: axis?.hasAttribute('x') ?? false,
          axisHasY: axis?.hasAttribute('y') ?? false,
          axisHasZ: axis?.hasAttribute('z') ?? false,
        });

        if (!plotResizeObservers.has(wrapper)) {
          const observer = new ResizeObserver(() => {
            drawPlot3d(canvas, plotEntries, parametricEntries, {
              xMin,
              xMax,
              yMin,
              yMax,
              zMin,
              zMax,
              uMin,
              uMax,
              vMin,
              vMax,
              step,
              axisHasX: axis?.hasAttribute('x') ?? false,
              axisHasY: axis?.hasAttribute('y') ?? false,
              axisHasZ: axis?.hasAttribute('z') ?? false,
            });
          });
          observer.observe(wrapper);
          plotResizeObservers.set(wrapper, observer);
        }
      });
    }

    function drawPlot(canvas, plotEntries, range) {
      const { xMin, xMax, yMin, yMax } = range;
      const parent = canvas.parentElement;
      const parentStyles = parent ? window.getComputedStyle(parent) : null;
      const paddingLeft = parentStyles ? Number.parseFloat(parentStyles.paddingLeft) : 0;
      const paddingRight = parentStyles ? Number.parseFloat(parentStyles.paddingRight) : 0;
      const availableWidth = (parent?.clientWidth ?? 520) - paddingLeft - paddingRight;
      const width = Math.max(availableWidth, 240);
      const height = 320;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;

      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, width, height);
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 1;

      for (let i = 1; i < 5; i += 1) {
        const x = (width * i) / 5;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let i = 1; i < 5; i += 1) {
        const y = (height * i) / 5;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }

      const xToPx = (x) => ((x - xMin) / (xMax - xMin)) * width;
      const yToPx = (y) => height - ((y - yMin) / (yMax - yMin)) * height;

      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1.2;
      if (xMin < 0 && xMax > 0) {
        const xAxis = xToPx(0);
        ctx.beginPath();
        ctx.moveTo(xAxis, 0);
        ctx.lineTo(xAxis, height);
        ctx.stroke();
      }
      if (yMin < 0 && yMax > 0) {
        const yAxis = yToPx(0);
        ctx.beginPath();
        ctx.moveTo(0, yAxis);
        ctx.lineTo(width, yAxis);
        ctx.stroke();
      }

      const logFn = (base, value) => Math.log(value) / Math.log(base);

      plotEntries.forEach((expression, index) => {
        let evaluator = null;
        try {
          evaluator = compileExpression(expression);
        } catch (error) {
          return;
        }

        ctx.strokeStyle = plotColors[index % plotColors.length];
        ctx.lineWidth = 2;
        ctx.beginPath();
        const steps = 600;
        let penDown = false;
        for (let i = 0; i <= steps; i += 1) {
          const x = xMin + ((xMax - xMin) * i) / steps;
          let y;
          try {
            y = evaluator(x, logFn);
          } catch (error) {
            y = NaN;
          }
          if (!Number.isFinite(y)) {
            penDown = false;
            continue;
          }
          const px = xToPx(x);
          const py = yToPx(y);
          if (!penDown) {
            ctx.moveTo(px, py);
            penDown = true;
          } else {
            ctx.lineTo(px, py);
          }
        }
        ctx.stroke();
      });

      ctx.fillStyle = '#333';
      ctx.font = '12px system-ui, sans-serif';
      ctx.fillText(`x: [${xMin}, ${xMax}]`, 8, height - 26);
      ctx.fillText(`y: [${yMin}, ${yMax}]`, 8, height - 10);
    }

    function drawPlot3d(canvas, plotEntries, parametricEntries, range) {
      const {
        xMin,
        xMax,
        yMin,
        yMax,
        zMin,
        zMax,
        uMin,
        uMax,
        vMin,
        vMax,
        step,
        axisHasX,
        axisHasY,
        axisHasZ,
      } = range;
      const parent = canvas.parentElement;
      const parentStyles = parent ? window.getComputedStyle(parent) : null;
      const paddingLeft = parentStyles ? Number.parseFloat(parentStyles.paddingLeft) : 0;
      const paddingRight = parentStyles ? Number.parseFloat(parentStyles.paddingRight) : 0;
      const availableWidth = (parent?.clientWidth ?? 520) - paddingLeft - paddingRight;
      const width = Math.max(availableWidth, 240);
      const height = 360;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;

      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, width, height);

      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 1;
      for (let i = 1; i < 5; i += 1) {
        const x = (width * i) / 5;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let i = 1; i < 5; i += 1) {
        const y = (height * i) / 5;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }

      const logFn = (base, value) => Math.log(value) / Math.log(base);
      let xMinFinal = xMin;
      let xMaxFinal = xMax;
      let yMinFinal = yMin;
      let yMaxFinal = yMax;
      let zMinFinal = zMin;
      let zMaxFinal = zMax;

      const hasParametric = parametricEntries.length > 0;
      if (hasParametric) {
        let bounds = null;
        parametricEntries.forEach((entry) => {
          let evaluatorX = null;
          let evaluatorY = null;
          let evaluatorZ = null;
          try {
            evaluatorX = compileParametricExpression(entry.x);
            evaluatorY = compileParametricExpression(entry.y);
            evaluatorZ = compileParametricExpression(entry.z);
          } catch (error) {
            return;
          }
          const stepsU = Math.max(2, Math.round((uMax - uMin) / step));
          const stepsV = Math.max(2, Math.round((vMax - vMin) / step));
          for (let vi = 0; vi <= stepsV; vi += 1) {
            const v = vMin + ((vMax - vMin) * vi) / stepsV;
            for (let ui = 0; ui <= stepsU; ui += 1) {
              const u = uMin + ((uMax - uMin) * ui) / stepsU;
              let px;
              let py;
              let pz;
              try {
                px = evaluatorX(u, v, logFn);
                py = evaluatorY(u, v, logFn);
                pz = evaluatorZ(u, v, logFn);
              } catch (error) {
                px = NaN;
                py = NaN;
                pz = NaN;
              }
              if (!Number.isFinite(px) || !Number.isFinite(py) || !Number.isFinite(pz)) {
                continue;
              }
              if (!bounds) {
                bounds = {
                  xMin: px,
                  xMax: px,
                  yMin: py,
                  yMax: py,
                  zMin: pz,
                  zMax: pz,
                };
              } else {
                bounds.xMin = Math.min(bounds.xMin, px);
                bounds.xMax = Math.max(bounds.xMax, px);
                bounds.yMin = Math.min(bounds.yMin, py);
                bounds.yMax = Math.max(bounds.yMax, py);
                bounds.zMin = Math.min(bounds.zMin, pz);
                bounds.zMax = Math.max(bounds.zMax, pz);
              }
            }
          }
        });

        if (bounds) {
          if (axisHasX) {
            xMinFinal = xMin;
            xMaxFinal = xMax;
          } else if (plotEntries.length > 0) {
            xMinFinal = Math.min(xMin, bounds.xMin);
            xMaxFinal = Math.max(xMax, bounds.xMax);
          } else {
            xMinFinal = bounds.xMin;
            xMaxFinal = bounds.xMax;
          }

          if (axisHasY) {
            yMinFinal = yMin;
            yMaxFinal = yMax;
          } else if (plotEntries.length > 0) {
            yMinFinal = Math.min(yMin, bounds.yMin);
            yMaxFinal = Math.max(yMax, bounds.yMax);
          } else {
            yMinFinal = bounds.yMin;
            yMaxFinal = bounds.yMax;
          }

          if (axisHasZ) {
            zMinFinal = zMin;
            zMaxFinal = zMax;
          } else if (plotEntries.length > 0) {
            zMinFinal = Math.min(zMin, bounds.zMin);
            zMaxFinal = Math.max(zMax, bounds.zMax);
          } else {
            zMinFinal = bounds.zMin;
            zMaxFinal = bounds.zMax;
          }
        }
      }

      const xSpan = xMaxFinal - xMinFinal;
      const ySpan = yMaxFinal - yMinFinal;
      const zSpan = zMaxFinal - zMinFinal;
      const xMid = (xMinFinal + xMaxFinal) / 2;
      const yMid = (yMinFinal + yMaxFinal) / 2;
      const zMid = (zMinFinal + zMaxFinal) / 2;
      const xHalf = xSpan === 0 ? 1 : xSpan / 2;
      const yHalf = ySpan === 0 ? 1 : ySpan / 2;
      const zHalf = zSpan === 0 ? 1 : zSpan / 2;
      const angle = Math.PI / 6;
      const cosAngle = Math.cos(angle);
      const sinAngle = Math.sin(angle);
      const scale = Math.min(width, height) * 0.38;
      const centerX = width * 0.5;
      const centerY = height * 0.45;

      const projectPoint = (x, y, z) => {
        const nx = (x - xMid) / xHalf;
        const ny = (y - yMid) / yHalf;
        const nz = (z - zMid) / zHalf;
        const isoX = (nx - ny) * cosAngle;
        const isoY = (nx + ny) * sinAngle - nz * 0.9;
        return {
          x: centerX + isoX * scale,
          y: centerY + isoY * scale,
        };
      };

      const stepsX = Math.max(2, Math.round((xMax - xMin) / step));
      const stepsY = Math.max(2, Math.round((yMax - yMin) / step));

      plotEntries.forEach((expression, index) => {
        let evaluator = null;
        try {
          evaluator = compileSurfaceExpression(expression);
        } catch (error) {
          return;
        }

        const grid = [];
        for (let yi = 0; yi <= stepsY; yi += 1) {
          const row = [];
          const y = yMin + (ySpan * yi) / stepsY;
          for (let xi = 0; xi <= stepsX; xi += 1) {
            const x = xMin + (xSpan * xi) / stepsX;
            let z;
            try {
              z = evaluator(x, y, logFn);
            } catch (error) {
              z = NaN;
            }
            if (!Number.isFinite(z)) {
              row.push(null);
            } else {
              row.push({ x, y, z });
            }
          }
          grid.push(row);
        }

        ctx.strokeStyle = plotColors[index % plotColors.length];
        ctx.lineWidth = 1.4;

        for (let yi = 0; yi < grid.length; yi += 1) {
          ctx.beginPath();
          let penDown = false;
          for (let xi = 0; xi < grid[yi].length; xi += 1) {
            const point = grid[yi][xi];
            if (!point) {
              penDown = false;
              continue;
            }
            const projected = projectPoint(point.x, point.y, point.z);
            if (!penDown) {
              ctx.moveTo(projected.x, projected.y);
              penDown = true;
            } else {
              ctx.lineTo(projected.x, projected.y);
            }
          }
          ctx.stroke();
        }

        for (let xi = 0; xi <= stepsX; xi += 1) {
          ctx.beginPath();
          let penDown = false;
          for (let yi = 0; yi <= stepsY; yi += 1) {
            const point = grid[yi][xi];
            if (!point) {
              penDown = false;
              continue;
            }
            const projected = projectPoint(point.x, point.y, point.z);
            if (!penDown) {
              ctx.moveTo(projected.x, projected.y);
              penDown = true;
            } else {
              ctx.lineTo(projected.x, projected.y);
            }
          }
          ctx.stroke();
        }
      });

      parametricEntries.forEach((entry, paramIndex) => {
        let evaluatorX = null;
        let evaluatorY = null;
        let evaluatorZ = null;
        try {
          evaluatorX = compileParametricExpression(entry.x);
          evaluatorY = compileParametricExpression(entry.y);
          evaluatorZ = compileParametricExpression(entry.z);
        } catch (error) {
          return;
        }

        const stepsU = Math.max(2, Math.round((uMax - uMin) / step));
        const stepsV = Math.max(2, Math.round((vMax - vMin) / step));
        const grid = [];
        for (let vi = 0; vi <= stepsV; vi += 1) {
          const row = [];
          const v = vMin + ((vMax - vMin) * vi) / stepsV;
          for (let ui = 0; ui <= stepsU; ui += 1) {
            const u = uMin + ((uMax - uMin) * ui) / stepsU;
            let px;
            let py;
            let pz;
            try {
              px = evaluatorX(u, v, logFn);
              py = evaluatorY(u, v, logFn);
              pz = evaluatorZ(u, v, logFn);
            } catch (error) {
              px = NaN;
              py = NaN;
              pz = NaN;
            }
            if (!Number.isFinite(px) || !Number.isFinite(py) || !Number.isFinite(pz)) {
              row.push(null);
            } else {
              row.push({ x: px, y: py, z: pz });
            }
          }
          grid.push(row);
        }

        ctx.strokeStyle = plotColors[(paramIndex + plotEntries.length) % plotColors.length];
        ctx.lineWidth = 1.4;

        for (let vi = 0; vi < grid.length; vi += 1) {
          ctx.beginPath();
          let penDown = false;
          for (let ui = 0; ui < grid[vi].length; ui += 1) {
            const point = grid[vi][ui];
            if (!point) {
              penDown = false;
              continue;
            }
            const projected = projectPoint(point.x, point.y, point.z);
            if (!penDown) {
              ctx.moveTo(projected.x, projected.y);
              penDown = true;
            } else {
              ctx.lineTo(projected.x, projected.y);
            }
          }
          ctx.stroke();
        }

        for (let ui = 0; ui <= stepsU; ui += 1) {
          ctx.beginPath();
          let penDown = false;
          for (let vi = 0; vi <= stepsV; vi += 1) {
            const point = grid[vi][ui];
            if (!point) {
              penDown = false;
              continue;
            }
            const projected = projectPoint(point.x, point.y, point.z);
            if (!penDown) {
              ctx.moveTo(projected.x, projected.y);
              penDown = true;
            } else {
              ctx.lineTo(projected.x, projected.y);
            }
          }
          ctx.stroke();
        }
      });

      const drawAxisLine = (start, end) => {
        const projectedStart = projectPoint(...start);
        const projectedEnd = projectPoint(...end);
        ctx.beginPath();
        ctx.moveTo(projectedStart.x, projectedStart.y);
        ctx.lineTo(projectedEnd.x, projectedEnd.y);
        ctx.stroke();
      };

      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1.2;
      if (xMinFinal <= 0 && xMaxFinal >= 0 && yMinFinal <= 0 && yMaxFinal >= 0 && zMinFinal <= 0 && zMaxFinal >= 0) {
        drawAxisLine([xMinFinal, 0, 0], [xMaxFinal, 0, 0]);
        drawAxisLine([0, yMinFinal, 0], [0, yMaxFinal, 0]);
        drawAxisLine([0, 0, zMinFinal], [0, 0, zMaxFinal]);
      }

      ctx.fillStyle = '#333';
      ctx.font = '12px system-ui, sans-serif';
      ctx.fillText(`x: [${xMinFinal}, ${xMaxFinal}]`, 8, height - 38);
      ctx.fillText(`y: [${yMinFinal}, ${yMaxFinal}]`, 8, height - 22);
      ctx.fillText(`z: [${zMinFinal}, ${zMaxFinal}]`, 8, height - 6);
    }

    function scheduleRender() {
      clearTimeout(timer);
      timer = setTimeout(render, 120);
    }

    // 入力のたびに即レンダリングすると重いので軽くデバウンス
    src.addEventListener('input', scheduleRender);
    src.addEventListener('scroll', syncScrollFromSource);
    src.addEventListener('click', scheduleRender);
    src.addEventListener('keyup', scheduleRender);
    src.addEventListener('select', scheduleRender);
    showCaret.addEventListener('change', scheduleRender);

    saveButton.addEventListener('click', () => {
      const baseName = getBaseFileName();
      const downloadName = buildDownloadFileName(baseName);
      const blob = new Blob([src.value], { type: 'text/markdown;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = downloadName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    });

    loadButton.addEventListener('click', () => {
      fileInput.value = '';
      fileInput.click();
    });

    fileInput.addEventListener('change', (event) => {
      const [file] = event.target.files;
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        src.value = reader.result ?? '';
        const normalizedName = normalizeLoadedFileName(file.name);
        fileNameInput.value = normalizedName;
        scheduleRender();
      };
      reader.readAsText(file);
    });

    // 初回描画
    window.addEventListener('load', render);

    function setPaneWidths(clientX) {
      const wrapRect = resizer.parentElement.getBoundingClientRect();
      const minPaneWidth = 160;
      const maxLeft = wrapRect.width - minPaneWidth - resizer.offsetWidth;
      const nextLeft = Math.min(Math.max(clientX - wrapRect.left, minPaneWidth), maxLeft);
      const rightWidth = wrapRect.width - nextLeft - resizer.offsetWidth;
      leftPane.style.flex = `0 0 ${nextLeft}px`;
      rightPane.style.flex = `0 0 ${rightWidth}px`;
    }

    resizer.addEventListener('pointerdown', (event) => {
      dragging = true;
      resizer.classList.add('dragging');
      resizer.setPointerCapture(event.pointerId);
      setPaneWidths(event.clientX);
    });

    resizer.addEventListener('pointermove', (event) => {
      if (!dragging) return;
      setPaneWidths(event.clientX);
    });

    resizer.addEventListener('pointerup', (event) => {
      dragging = false;
      resizer.classList.remove('dragging');
      resizer.releasePointerCapture(event.pointerId);
    });

    resizer.addEventListener('pointercancel', () => {
      dragging = false;
      resizer.classList.remove('dragging');
    });
  </script>
</body>
</html>









