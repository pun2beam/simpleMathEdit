<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="./favicon.ico" sizes="any">
  <link rel="stylesheet" href="./style.css" />
  <title>MathJax Live Preview</title>

  <!-- MathJax v3 -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
      },
    };
  </script>
  <script defer src="./es5/tex-mml-chtml.js"></script>
  <script src="./marked/marked.min.js"></script>

</head>
<body>
  <div class="wrap">
    <div class="pane" id="left-pane">
      <div class="editor-header">
        <label class="file-label" for="file-name">ファイル名:</label>
        <input id="file-name" type="text" placeholder="ファイル名" value="notes" />
        <button id="save-button" type="button">Save</button>
        <button id="load-button" type="button">Load</button>
        <input id="file-input" type="file" accept=".md,text/markdown,text/plain" hidden />
      </div>
      <label class="caret-toggle">
        <input id="show-caret" type="checkbox" checked />
        キャレットをプレビューに表示
      </label>
      <textarea id="src">
インライン: $E=mc^2$

別行表示:
$$
\frac{\mathrm{d}y}{\mathrm{d}x}=g(y)h(x)
$$
      </textarea>
    </div>

    <div class="resizer" id="resizer" role="separator" aria-label="Resize panes" aria-orientation="vertical"></div>

    <div class="pane preview" id="right-pane">
      <div id="out"></div>
    </div>
  </div>

  <script>
    const src = document.getElementById('src');
    const out = document.getElementById('out');
    const resizer = document.getElementById('resizer');
    const leftPane = document.getElementById('left-pane');
    const rightPane = document.getElementById('right-pane');
    const fileNameInput = document.getElementById('file-name');
    const saveButton = document.getElementById('save-button');
    const loadButton = document.getElementById('load-button');
    const fileInput = document.getElementById('file-input');
    const showCaret = document.getElementById('show-caret');
    let timer = null;
    let renderInProgress = false;
    let renderQueued = false;
    let dragging = false;

    marked.setOptions({ mangle: false, headerIds: false });

    const caretToken = '│';
    const caretHtml = '<span id="caret-marker" aria-hidden="true" data-mjx-skip="true">▌</span>';

    function buildSourceWithCaret() {
      const caretIndex = src.selectionStart ?? 0;
      return `${src.value.slice(0, caretIndex)}${caretToken}${src.value.slice(caretIndex)}`;
    }

    function syncScrollFromSource() {
      const outMax = out.scrollHeight - rightPane.clientHeight;
      if (outMax <= 0) {
        rightPane.scrollTop = 0;
        return;
      }
      const caretIndex = src.selectionStart ?? 0;
      const beforeCaret = src.value.slice(0, caretIndex);
      const caretLine = beforeCaret.split('\n').length;
      const totalLines = Math.max(src.value.split('\n').length, 1);
      const ratio = Math.min(Math.max((caretLine - 1) / Math.max(totalLines - 1, 1), 0), 1);
      const targetScrollTop = ratio * outMax;
      rightPane.scrollTop = targetScrollTop;
    }

    function normalizeDisplayMath(source) {
      const lines = source.split('\n');
      const normalized = [];
      let inDisplay = false;

      for (let line of lines) {
        if (line.trim() === '$$') {
          inDisplay = !inDisplay;
          normalized.push('$$');
          continue;
        }

        if (inDisplay && line.trim() === '') {
          continue;
        }

        if (inDisplay) {
          line = line.replace(/\\/g, '\\\\');
        }

        normalized.push(line);
      }

      return normalized.join('\n');
    }

    function formatDateTime(date) {
      const pad = (value) => String(value).padStart(2, '0');
      return `${date.getFullYear()}${pad(date.getMonth() + 1)}${pad(date.getDate())}${pad(date.getHours())}${pad(date.getMinutes())}`;
    }

    function getBaseFileName() {
      const rawName = fileNameInput.value.trim();
      return rawName === '' ? 'notes' : rawName.replace(/\.md$/i, '');
    }

    function buildDownloadFileName(baseName) {
      const timestamp = formatDateTime(new Date());
      return `${baseName}_${timestamp}.md`;
    }

    function normalizeLoadedFileName(fileName) {
      const match = fileName.match(/^(.*)_([0-9]+)\.md$/i);
      if (match && /^[0-9]+$/.test(match[2])) {
        return match[1];
      }
      if (/\.md$/i.test(fileName)) {
        return fileName.replace(/\.md$/i, '');
      }
      return fileName;
    }

    async function render() {
      if (renderInProgress) {
        renderQueued = true;
        return;
      }
      renderInProgress = true;
      const sourceWithCaret = normalizeDisplayMath(
        showCaret.checked ? buildSourceWithCaret() : src.value
      );
      // const html = marked.parse(sourceWithCaret);
      // out.innerHTML = html.replace(caretToken, caretHtml);
      out.innerHTML = marked.parse(sourceWithCaret);
      renderPlots(out);

      // MathJaxの準備完了待ち（初回読み込み中の事故防止）
      if (!window.MathJax || !MathJax.typesetPromise) {
        renderInProgress = false;
        return;
      }

      // 右ペインだけ再レンダリング
      MathJax.typesetClear([out]);
      try {
        await MathJax.typesetPromise([out]);
        syncScrollFromSource();
      } finally {
        renderInProgress = false;
        if (renderQueued) {
          renderQueued = false;
          scheduleRender();
        }
      }
    }

    const plotColors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'];
    const plotResizeObservers = new WeakMap();

    function parseRangeAttribute(value, fallback) {
      if (!value) return fallback;
      const matches = value.match(/[-+]?\d*\.?\d+(?:e[-+]?\d+)?/gi);
      if (!matches || matches.length < 2) return fallback;
      const min = Number(matches[0]);
      const max = Number(matches[1]);
      if (!Number.isFinite(min) || !Number.isFinite(max) || min === max) return fallback;
      return [min, max];
    }

    function compileExpression(expression) {
      const normalized = expression
        .replace(/\bpi\b/gi, 'Math.PI')
        .replace(/\be\b/g, 'Math.E')
        .replace(/\bpower\s*\(/gi, 'Math.pow(')
        .replace(/\blog\s*\(/gi, '__log(')
        .replace(/\bsin\s*\(/gi, 'Math.sin(')
        .replace(/\bcos\s*\(/gi, 'Math.cos(')
        .replace(/\btan\s*\(/gi, 'Math.tan(');

      return new Function('x', '__log', `return (${normalized});`);
    }

    function renderPlots(container) {
      const plotBlocks = Array.from(container.querySelectorAll('plots'));
      plotBlocks.forEach((plotBlock) => {
        const axis = plotBlock.querySelector('axis');
        const [xMin, xMax] = parseRangeAttribute(axis?.getAttribute('x'), [-10, 10]);
        const [yMin, yMax] = parseRangeAttribute(axis?.getAttribute('y'), [-10, 10]);
        const plotEntries = Array.from(plotBlock.querySelectorAll('plot'))
          .map((plotNode) => plotNode.getAttribute('y'))
          .filter(Boolean);

        const wrapper = document.createElement('div');
        wrapper.className = 'plot-container';
        wrapper.setAttribute('data-mjx-skip', 'true');

        const canvas = document.createElement('canvas');
        canvas.className = 'plot-canvas';
        wrapper.appendChild(canvas);

        if (plotEntries.length > 0) {
          const legend = document.createElement('div');
          legend.className = 'plot-legend';
          plotEntries.forEach((expression, index) => {
            const item = document.createElement('div');
            item.className = 'plot-legend-item';
            const swatch = document.createElement('span');
            swatch.className = 'plot-legend-swatch';
            swatch.style.backgroundColor = plotColors[index % plotColors.length];
            item.appendChild(swatch);
            const label = document.createElement('span');
            label.textContent = `y = ${expression}`;
            item.appendChild(label);
            legend.appendChild(item);
          });
          wrapper.appendChild(legend);
        }

        plotBlock.replaceWith(wrapper);
        drawPlot(canvas, plotEntries, { xMin, xMax, yMin, yMax });

        if (!plotResizeObservers.has(wrapper)) {
          const observer = new ResizeObserver(() => {
            drawPlot(canvas, plotEntries, { xMin, xMax, yMin, yMax });
          });
          observer.observe(wrapper);
          plotResizeObservers.set(wrapper, observer);
        }
      });
    }

    function drawPlot(canvas, plotEntries, range) {
      const { xMin, xMax, yMin, yMax } = range;
      const parent = canvas.parentElement;
      const parentStyles = parent ? window.getComputedStyle(parent) : null;
      const paddingLeft = parentStyles ? Number.parseFloat(parentStyles.paddingLeft) : 0;
      const paddingRight = parentStyles ? Number.parseFloat(parentStyles.paddingRight) : 0;
      const availableWidth = (parent?.clientWidth ?? 520) - paddingLeft - paddingRight;
      const width = Math.max(availableWidth, 240);
      const height = 320;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;

      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, width, height);
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 1;

      for (let i = 1; i < 5; i += 1) {
        const x = (width * i) / 5;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let i = 1; i < 5; i += 1) {
        const y = (height * i) / 5;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }

      const xToPx = (x) => ((x - xMin) / (xMax - xMin)) * width;
      const yToPx = (y) => height - ((y - yMin) / (yMax - yMin)) * height;

      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1.2;
      if (xMin < 0 && xMax > 0) {
        const xAxis = xToPx(0);
        ctx.beginPath();
        ctx.moveTo(xAxis, 0);
        ctx.lineTo(xAxis, height);
        ctx.stroke();
      }
      if (yMin < 0 && yMax > 0) {
        const yAxis = yToPx(0);
        ctx.beginPath();
        ctx.moveTo(0, yAxis);
        ctx.lineTo(width, yAxis);
        ctx.stroke();
      }

      const logFn = (base, value) => Math.log(value) / Math.log(base);

      plotEntries.forEach((expression, index) => {
        let evaluator = null;
        try {
          evaluator = compileExpression(expression);
        } catch (error) {
          return;
        }

        ctx.strokeStyle = plotColors[index % plotColors.length];
        ctx.lineWidth = 2;
        ctx.beginPath();
        const steps = 600;
        let penDown = false;
        for (let i = 0; i <= steps; i += 1) {
          const x = xMin + ((xMax - xMin) * i) / steps;
          let y;
          try {
            y = evaluator(x, logFn);
          } catch (error) {
            y = NaN;
          }
          if (!Number.isFinite(y)) {
            penDown = false;
            continue;
          }
          const px = xToPx(x);
          const py = yToPx(y);
          if (!penDown) {
            ctx.moveTo(px, py);
            penDown = true;
          } else {
            ctx.lineTo(px, py);
          }
        }
        ctx.stroke();
      });

      ctx.fillStyle = '#333';
      ctx.font = '12px system-ui, sans-serif';
      ctx.fillText(`x: [${xMin}, ${xMax}]`, 8, height - 26);
      ctx.fillText(`y: [${yMin}, ${yMax}]`, 8, height - 10);
    }

    function scheduleRender() {
      clearTimeout(timer);
      timer = setTimeout(render, 120);
    }

    // 入力のたびに即レンダリングすると重いので軽くデバウンス
    src.addEventListener('input', scheduleRender);
    src.addEventListener('scroll', syncScrollFromSource);
    src.addEventListener('click', scheduleRender);
    src.addEventListener('keyup', scheduleRender);
    src.addEventListener('select', scheduleRender);
    showCaret.addEventListener('change', scheduleRender);

    saveButton.addEventListener('click', () => {
      const baseName = getBaseFileName();
      const downloadName = buildDownloadFileName(baseName);
      const blob = new Blob([src.value], { type: 'text/markdown;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = downloadName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    });

    loadButton.addEventListener('click', () => {
      fileInput.value = '';
      fileInput.click();
    });

    fileInput.addEventListener('change', (event) => {
      const [file] = event.target.files;
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        src.value = reader.result ?? '';
        const normalizedName = normalizeLoadedFileName(file.name);
        fileNameInput.value = normalizedName;
        scheduleRender();
      };
      reader.readAsText(file);
    });

    // 初回描画
    window.addEventListener('load', render);

    function setPaneWidths(clientX) {
      const wrapRect = resizer.parentElement.getBoundingClientRect();
      const minPaneWidth = 160;
      const maxLeft = wrapRect.width - minPaneWidth - resizer.offsetWidth;
      const nextLeft = Math.min(Math.max(clientX - wrapRect.left, minPaneWidth), maxLeft);
      const rightWidth = wrapRect.width - nextLeft - resizer.offsetWidth;
      leftPane.style.flex = `0 0 ${nextLeft}px`;
      rightPane.style.flex = `0 0 ${rightWidth}px`;
    }

    resizer.addEventListener('pointerdown', (event) => {
      dragging = true;
      resizer.classList.add('dragging');
      resizer.setPointerCapture(event.pointerId);
      setPaneWidths(event.clientX);
    });

    resizer.addEventListener('pointermove', (event) => {
      if (!dragging) return;
      setPaneWidths(event.clientX);
    });

    resizer.addEventListener('pointerup', (event) => {
      dragging = false;
      resizer.classList.remove('dragging');
      resizer.releasePointerCapture(event.pointerId);
    });

    resizer.addEventListener('pointercancel', () => {
      dragging = false;
      resizer.classList.remove('dragging');
    });
  </script>
</body>
</html>









